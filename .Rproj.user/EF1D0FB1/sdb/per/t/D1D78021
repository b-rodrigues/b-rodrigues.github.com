{
    "collab_server" : "",
    "contents" : "---\ndate: 2020-01-26\ntitle: \"Dynamic discrete choice models, reinforcement learning and Harold, part 1\"\ntags: [R]\nmenu:\nmain:\n  parent: Blog\n  identifier: /blog/harold\n  weight: 1\n---\n\n<div style=\"text-align:center;\">\n<a href=\"https://www.youtube.com/watch?v=r30D3SW4OVw\">\n  <img src=\"/img/fork.jpg\" title = \"If this blog post had an OST, this would likely be it.\"></a>\n</div>\n\n\n```{r, include=FALSE}\nlibrary(tidyverse)\nlibrary(lubridate)\n```\n\n## Introduction\n\nI want to write about an *Econometrica* paper written in 1987 ([jstor link](https://www.jstor.org/stable/1911259)) by John Rust, currently Professor of Economics at \nGeorgetown University, paper which has been on my mind for the past 10 years or so. Why? Because\nit is a seminal paper in the econometric literature, but it is quite a bizarre one in some aspects. \nIn this paper, John Rust estimates a structural\ndynamic discrete choice model on real data, and Professor Rust even had to develop his own novel\nalgorithm, which he called NFXP, which stands for *Nested Fixed Point* algorithm, to estimate the model.\nSuch models hare now part of the toolbox of structural econometricians, because said models are \nsuited to model decision making in a changing environment. How much should you save today for \nretirement? Should you go to university? If yes, which major should you choose? Should you get a \nPhD? Should you have kids? How many? With whom? \nAs you see, kind reader, these models are at the center point of what makes life so interesting, \nand sometimes so scary as well; what will be the impact of our decisions today on future rewards?\nSome would say that only the Almighty would know, but structural econometricians now know as well, \nthanks to John Rust.\n\nIt is thus completely natural that Professor Rust chose a very important topic and gathered some\nvery important data to illustrate the inner workings of such a complicated, and yet fundamentally\nimportant model.\n\nJohn Rust chose to tell the story of one named Harold Zurcher, superintendent of the Madison, \nWisconsin, Metropolitan Bus Company and his monthly decision making process on whether to replace \nthe engine of the buses of the company's fleet, or not.\n\n## *And thine ears shall hear a word behind thee, saying, This is the way, walk ye in it, when ye turn to the right hand, and when ye turn to the left.*, Isaiah 30:21\n\nJohn Rust's goal is to write down a model of Harold Zurcher's behaviour, which he assumes follows\nan optimal stopping rule: *a strategy which specifies whether or not to replace\nthe current bus engine each period as a function of observed and unobserved\nstate variables.* But, dear reader, you might wonder, *Why model the decisions of Harold Zurcher? \nWhy not any other, more pressing, issue?*\n\nQuoting the author gives an answer: *Admittedly, few people are likely to take particular interest in Harold Zurcher and bus engine replacement, per se. I focus on a particular individual and a\nspecific capital good because it provides a simple, concrete framework to illustrate\ntwo ideas: (i) a \"bottom-up\" approach for modelling replacement investment\nand (ii) a \"nested fixed point\" algorithm for estimating dynamic programming\nmodels of discrete choice.* And this is what made me absolutely love this paper; I am 100% certain\nthat today, anyone, especially when starting an academic career, could not, and would not, write \na paper where one would model something so... non-consequential. And yet, John Rust not only wrote\nsuch a paper, his paper is seminal in the literature of structural econometrics. For me, this is \none of the best papers I ever read. I read this paper around 2010-ish, and have thought about \nit on and off since then. I now want to explore the data from his paper, and make you discover \nit as well.\n\nIn this blog post, I will focus on the data of the paper, which you can download in its raw,\noriginal format or tidy format in the github repo I set up\n[here](https://github.com/b-rodrigues/rust/tree/master/datasets). In the next blog post, I'll\ndiscuss the model in greater detail, with a focus on Harold Zurcher's decisions. I'll then discuss\nthe similarities between reinforcement learning (the title of this blog post was not 100% clickbait)\nand dynamic discrete stochastic models and use the `{ReinforcementLearning}` package to try to \nestimate the optimal policy. I haven't tried the package's function on this paper's data yet, so\nI have no idea if it's going to work out. We'll see.\n\n## The paper's data\n\nHarold Zurcher provided monthly data on odometer readings from 162 buses of the Madison Metro fleet\nto John Rust. \n\n(\n\nI sometimes wonder how this discussion went. \n\n*- Hello Mr Zurcher, I'm an economist, my name is John Rust, and I am interested in dynamic discrete\nchoice models and their estimation. I would like to write an empirical paper for a prestigious journal,\nand would like to know if you would be so kind as to provide me with data for my paper.*\n\n*- You what?*\n\n)\n\nThe time period goes from December, 1974 to May, 1985. There are 9 groups of buses, but for a reason\nthat is not explained in the paper only 8 groups of buses are studied. In addition to the monthly\nodometer readings, there is also the date of a first, or second engine replacement. This is the \ndecision that Harold Zurcher faces each month: should he replace, or not, the engine? \nThis is a simplification from the author; in actuality, Harold Zurcher could also perform a routine\nmaintenance or replace individual components as well. The idea to focus on the third option\n(complete replacement of the engine) is justified by John Rust as being part of a general \n\"preventive maintenance\" strategy. Indeed, if a component of the engine fails at low mileage, it\nis rather safe to simply replace that component. However, should one component of the engine fail\nat a much higher mileage, then it is very likely that other components would fail as well in the\nnear future. As such, it is much safer to completely replace the engine, either with a brand new one,\nor with one freshly rebuilt from the company's machine shop. John Rust points out that Harold Zurcher\nassured him that *rebuilt engines are every bit as good, if not better, than engines purchased brand\nnew*.\n\nNow, to the data itself. The data comes in a format unlike anything I had ever seen before. Let's take a\nlook at the head of one single file, for instance `a452372.asc` (`.asc` stands for ascii, as far as I know):\n\n```\n   4239 \n      2 \n     72 \n      1 \n     76 \n 166100 \n      0 \n      0 \n      0 \n     12 \n     74 \n 140953 \n 142960 \n 145380 \n 148140 \n```\n\nThen, on line 138, the data for the second bus of this groups starts:\n\n```\n   4240 \n      2 \n     72 \n      1 \n     75 \n 177900 \n      0 \n      0 \n      0 \n     12 \n     74 \n 174402 \n 175116 \n```\n\nand so on for each bus of this group. The other files are structured in the same way.\n\nThis is quite cryptic, but thankfully, the data is well documented in the manual\nof the NFXP software that John Rust wrote for this paper (remember the algorithm he wrote to\nestimate the model? He shared his code with a nice manual, a very good practice that \nunfortunately is not widespread enough in econometric circles, even to this day).\nFrom this manual, we can read that the 11 first lines of the file are some kind of metadata:\n\n| Row &nbsp;| Meaning | Observation |\n|---:|-------|-----------:|\n|1 &nbsp;   | bus number        |     4239        |\n|2 &nbsp;   | month purchased        |    2         |\n|3 &nbsp;   | year purchased        |     72        |\n|4 &nbsp;   | month of 1st engine replacement        |      1       |\n|5 &nbsp;   | year of 1st engine replacement        |   76          |\n|6 &nbsp;   | odometer at replacement        |      166100       |\n|7 &nbsp;   | month of 2nd replacement        |         0    |\n|8 &nbsp;   | year of 2nd replacement        |  0           |\n|9 &nbsp;   | odometer at replacement        |   0          |\n|10 &nbsp;  | month odometer data begins        |   12          |\n|11 &nbsp;  | year odometer data begins        |     74        |\n|12 &nbsp;  | odometer reading        |  140953           |\n\n\nWith this knowledge, the first step is thus to build a tidy data frame. To achieve this, I first\nload the relevant packages, and read in all the data at once:\n\n```{r, eval=FALSE}\nlibrary(tidyverse)\nlibrary(lubridate)\n\ndata_file_path <- Sys.glob(\"datasets/*.asc\")\n\ndata_files <- map(data_file_path, read_lines)\n```\n\n`data_files` is a list of 9 elements, where each element is one of the raw data files \n(`a42372.asc`, `a452374.asc`, ....)\n\n```{r, eval=FALSE}\n> str(data_files)\n```\n\n```{r, eval=FALSE}\nList of 9\n $ : chr [1:2466] \"   4239 \" \"      2 \" \"     72 \" \"      1 \" ...\n $ : chr [1:1370] \"   4287 \" \"     10 \" \"     74 \" \"     11 \" ...\n $ : chr [1:2466] \"   5257 \" \"      5 \" \"     72 \" \"      6 \" ...\n $ : chr [1:1644] \"   5275 \" \"     10 \" \"     74 \" \"      9 \" ...\n $ : chr [1:4736] \"   5297 \" \"      8 \" \"     75 \" \"      4 \" ...\n $ : chr [1:440] \"   1334 \" \"      3 \" \"     77 \" \"      0 \" ...\n $ : chr [1:540] \"   4403 \" \"      5 \" \"     83 \" \"      0 \" ...\n $ : chr [1:240] \"   2386 \" \"      5 \" \"     81 \" \"      0 \" ...\n $ : chr [1:3888] \"   4338 \" \"      3 \" \"     79 \" \"      3 \" ...\n```\n\nto process all this data, I wrote this monster function:\n\n```{r, eval=FALSE}\nprocess_bus_data <- function(data_file){\n  data_file <- as.numeric(data_file)\n  first_bus <- data_file[1]\n  second_bus <- first_bus + 1\n  second_bus_index <- which(data_file == second_bus)\n\n  nb_data_points <- second_bus_index - 1\n\n  nb_buses <- length(data_file) / nb_data_points\n\n  indices <- nb_data_points * seq(1, nb_buses)\n\n  indices <- c(0, indices)\n\n  sep_data_sets <- map(indices, ~`[`(data_file, (. + 1):(. + nb_data_points) ))\n\n  headers_list <- map(sep_data_sets, ~`[`(., 1:11))\n\n  header_elements <- c(\"bus number\", \"month purchased\", \"year purchased\",\n                       \"month of 1st engine replacement\", \"year of 1st engine replacement\",\n                       \"odometer at replacement\", \"month of 2nd replacement\",\n                       \"year of 2nd replacement\", \"odometer at replacement\",\n                       \"month odometer data begins\", \"year odometer data begins\")\n\n  create_start_date <- function(one_dataset){\n      one_dataset <- pull(one_dataset)\n      month <- one_dataset[10]\n      year <- paste0(\"19\", one_dataset[11])\n\n      month <- ifelse(nchar(month) == 1, paste0(\"0\", month), month)\n\n      ymd(paste0(year, \"-\", month, \"-01\"))\n  }\n\n  create_first_replacement <- function(one_dataset){\n      one_dataset <- pull(one_dataset, odometer_reading)\n      month <- one_dataset[4]\n      year <- paste0(\"19\", one_dataset[5])\n\n      month <- ifelse(nchar(month) == 1, paste0(\"0\", month), month)\n\n      ymd(paste0(year, \"-\", month, \"-01\"))\n  }\n\n  create_second_replacement <- function(one_dataset){\n      one_dataset <- pull(one_dataset, odometer_reading)\n      month <- one_dataset[7]\n      year <- paste0(\"19\", one_dataset[8])\n\n      month <- ifelse(nchar(month) == 1, paste0(\"0\", month), month)\n\n      ymd(paste0(year, \"-\", month, \"-01\"))\n  }\n\n  get_bus_id <- function(one_dataset){\n      one_dataset <- pull(one_dataset, odometer_reading)\n      one_dataset[1]\n  }\n\n  named_headers <- map(headers_list, ~set_names(., header_elements))\n\n\n  raw_data <- map(sep_data_sets, ~tibble(\"odometer_reading\" = .))\n  raw_data <- map(raw_data, ~mutate(., \"date\" = create_start_date(.)))\n  raw_data <- map(raw_data, ~mutate(., \"first_replacement_date\" = create_first_replacement(.)))\n  raw_data <- map(raw_data, ~mutate(., \"second_replacement_date\" = create_second_replacement(.)))\n  raw_data <- map(raw_data, ~mutate(., \"bus_id\" = get_bus_id(.)))\n  raw_data <- map(raw_data, ~slice(., -c(1:11)))\n\n  fill_dates <- function(vector){\n      for(i in 2:length(vector)){\n          vector[i] <- add_with_rollback(vector[i-1], months(1))\n          # the line below can be uncommented to skip the 2 months of strike in 1980\n          #vector[i] <- if_else(vector[i] == ymd(\"1980-07-01\"), add_with_rollback(vector[i], months(2)),\n          #                    vector[i])\n      }\n      vector\n  }\n\n  raw_data <- raw_data %>%\n      map(~mutate(., date = fill_dates(date)))\n\n  raw_data <- map(raw_data, ~mutate(., \"replacement_1\" = if_else(date == first_replacement_date, 1, 0, 0)))\n  raw_data <- map(raw_data, ~mutate(., \"replacement_2\" = if_else(date == second_replacement_date, 1, 0, 0)))\n  raw_data <- map(raw_data, ~mutate(., replacement = replacement_1 + replacement_2))\n  raw_data <- map(raw_data, ~select(., bus_id, date, odometer_reading, replacement,\n                                    -replacement_1, -replacement_2, -first_replacement_date, -second_replacement_date))\n\n  return(raw_data)\n}\n```\n\nNow, as usual, I didn't write this in one go. First, I experimented bits and pieces of code on\none single dataset, and then only started putting these pieces together into this big function.\n\nI won't go through this function line by line, because it would take me ages. I think there are\ntwo majors things to understand in this function:\n\n- first identify the start of a particular bus's data;\n- second this function uses some intermediary `{purrr}` magic.\n\nSo first step, identify the start of the monthly odometer reading for one bus. For the first bus\nthis is quite simple, as it is simply the start of the file. But when does the data for the \nsecond bus start? Thankfully, buses' ids are numbers, and they're in incrementing order in the data.\nI use this to get the index of the second bus, and compute the number of rows between the id of \nthe first and second bus, which gives me the number of months of odometer readings for the first\nbus.\n\n```{r, eval=F}\n  data_file <- as.numeric(data_file)\n  first_bus <- data_file[1]\n  second_bus <- first_bus + 1\n  second_bus_index <- which(data_file == second_bus)\n\n  nb_data_points <- second_bus_index - 1\n```\n\nThen, I get the number of buses in the data, and create a vector with all the indices of the \nbuses' ids:\n\n```{r, eval=FALSE}\n  nb_buses <- length(data_file) / nb_data_points\n\n  indices <- nb_data_points * seq(1, nb_buses)\n\n  indices <- c(0, indices)\n\n  sep_data_sets <- map(indices, ~`[`(data_file, (. + 1):(. + nb_data_points) ))\n```\n\nI end up with a list of lists, `sep_data_sets`. \nThe first element of my list is now a list, with the data from the\n`a452372.asc` file, where each element is the data for a single bus.\n\nFor instance, here is the first element of `sep_data_sets`:\n\n```{r, eval=FALSE}\nstr(sep_data_sets[[1]])\nList of 19\n $ : num [1:137] 4239 2 72 1 76 ...\n $ : num [1:137] 4240 2 72 1 75 ...\n $ : num [1:137] 4241 2 72 5 75 ...\n $ : num [1:137] 4242 2 72 2 76 ...\n $ : num [1:137] 4243 2 72 4 76 ...\n $ : num [1:137] 4244 2 72 3 78 ...\n $ : num [1:137] 4245 2 72 1 75 ...\n $ : num [1:137] 4246 2 72 3 75 ...\n $ : num [1:137] 4247 2 72 9 80 ...\n $ : num [1:137] 4248 2 72 2 75 ...\n $ : num [1:137] 4249 2 72 7 75 ...\n $ : num [1:137] 4250 2 72 4 80 ...\n $ : num [1:137] 4251 2 72 1 79 ...\n $ : num [1:137] 4252 2 72 5 76 ...\n $ : num [1:137] 4253 2 72 1 77 ...\n $ : num [1:137] 4254 2 72 3 76 ...\n $ : num [1:137] 4255 2 72 1 76 ...\n $ : num [1:137] 4256 2 72 9 77 ...\n $ : num [1:137] NA NA NA NA NA NA NA NA NA NA ...\n```\n\nSo there are 18 buses in the first group of data (the last line full of NA's is due to the fact\nthat I messed up my indices vector, I'll simply remove these at the end).\n\nThat's the first step. The second step, is to make use of this list structure to apply some \ncleaning functions to each dataset using `{purrr}`. I explain the approach in my ebook, which you\ncan read for free \n[here](https://b-rodrigues.github.io/modern_R/functional-programming.html#list-based-workflows-for-efficiency). \nThe idea is to use a function that would work on a single element of your list, and then mapping \nthis over all the elements of the list. For instance, remember that the 11 first elements of\nthe data are some kind of header? To extract those for one single vector of observations, one\nwould use:\n\n```{r, eval=FALSE}\nmy_vector[1:11]\n```\n\nor, equivalently:\n\n```{r, eval = FALSE}\n`[`(my_vector, 1:11)\n```\n\nWell, when faced with a list of vectors, one maps this function over the whole list using `map()`:\n\n```{r, eval=FALSE}\nmap(my_list_of_vectors, `[`(1:11))\n```\n\nThis is the logic of this big `process_bus_data()` function. If something's not clear after you study\nit, drop me an email or tweet.\n\nAnyways, now that I cleaned the data, here's how it looks:\n\n```{r}\nall_buses <- read_csv(\"https://raw.githubusercontent.com/b-rodrigues/rust/ee15fb87fc4ba5db28d055c97a898b328725f53c/datasets/processed_data/all_buses.csv\")\n\n\nhead(all_buses)\n```\n\nThis tidy data frame now has the bus id, the odometer readings with the right date, and whether \na replacement occurred at that date. I said the right date, but in the original documentation of \nthe data, John Rust mentions a two month strike in July and August 1980, and he removed these \npoints from the data since the odometer readings where the same. I did not skip July and August\nwhen I created the dates, even though I have added the code to do it in the function above, because\nit does not matter. \n\nI have `r length(unique(all_buses$bus_id))` in my sample, while John Rust writes in the paper that \nhis sample contains 162. I do not know why I have 4 more buses.\n\nLet's try to reproduce Table 2a of the paper (mileage at replacement):\n\n```{r}\nall_buses %>% \n    group_by(bus_id) %>% \n    filter(replacement == 1) %>% \n    group_by(bus_family) %>% \n    summarise_at(.vars = vars(odometer_reading), \n                 .funs = list(~max(.), ~min(.), ~mean(.), ~sd(.)))\n```\n\nI find different slightly results, for instance, for bus family `t8h203` I find an average of \n200'685 miles, while the original author found  199'733. This difference comes very likely from\nthe fact that the author probably uses the value from the header, \"odometer at replacement\", at\nposition 6, while I use the value of the odometer at that month, which is always slightly different.\n\nLet's try to reproduce Table 2b, as well, mileage for buses who did not have a replacement:\n\n```{r}\nall_buses %>% \n    group_by(bus_id) %>% \n    filter(all(replacement == 0)) %>% \n    group_by(bus_family) %>% \n    summarise_at(.vars = vars(odometer_reading), \n                 .funs = list(~max(.), ~min(.), ~mean(.), ~sd(.)))\n```\n\nHere I find exactly the same values as the author. To finish this quite long blog post, let's\nnow plot the data:\n\n```{r}\nggplot(all_buses) + \n    geom_line(aes(y = odometer_reading, x = date, group = bus_id, col = bus_family)) + \n    labs(title = \"Odometer readings\") +\n    brotools::theme_blog()\n```\n\nLet's add some dots to mark the points in time where replacements happened:\n\n```{r}\nggplot(all_buses) + \n    geom_line(aes(y = odometer_reading, x = date, group = bus_id, col = bus_family)) + \n    geom_point(aes(y = ifelse(odometer_reading*replacement == 0, NA, odometer_reading*replacement), \n                              x = date), col = \"red\") +\n    labs(title = \"Odometer readings and points in time where engine replacement occurred\") +\n    brotools::theme_blog()\n```\n\n\nLet's create a graph for each bus family:\n\n```{r}\nggplot(all_buses) + \n    geom_line(aes(y = odometer_reading, x = date, group = bus_id), col = \"#82518c\") +\n    geom_point(aes(y = ifelse(odometer_reading*replacement == 0, NA, odometer_reading*replacement), \n                              x = date), col = \"red\") +\n    facet_wrap(~bus_family) + \n    labs(title = \"Odometer readings and points in time where engine replacement occurred\") +\n    brotools::theme_blog()\n```\n\nIn the next blog post, I'll explore how recent reinforcement learning methods might help us get\nthe optimal policy from the data!\n\nHope you enjoyed! If you found this blog post useful, you might want to follow \nme on [twitter](https://www.twitter.com/brodriguesco) for blog post updates and \n[buy me an espresso](https://www.buymeacoffee.com/brodriguesco) or [paypal.me](https://www.paypal.me/brodriguesco), or buy my ebook on [Leanpub](https://leanpub.com/modern_tidyverse).\n\n<style>.bmc-button img{width: 27px !important;margin-bottom: 1px !important;box-shadow: none !important;border: none !important;vertical-align: middle !important;}.bmc-button{line-height: 36px !important;height:37px !important;text-decoration: none !important;display:inline-flex !important;color:#ffffff !important;background-color:#272b30 !important;border-radius: 3px !important;border: 1px solid transparent !important;padding: 1px 9px !important;font-size: 22px !important;letter-spacing:0.6px !important;box-shadow: 0px 1px 2px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;margin: 0 auto !important;font-family:'Cookie', cursive !important;-webkit-box-sizing: border-box !important;box-sizing: border-box !important;-o-transition: 0.3s all linear !important;-webkit-transition: 0.3s all linear !important;-moz-transition: 0.3s all linear !important;-ms-transition: 0.3s all linear !important;transition: 0.3s all linear !important;}.bmc-button:hover, .bmc-button:active, .bmc-button:focus {-webkit-box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;text-decoration: none !important;box-shadow: 0px 1px 2px 2px rgba(190, 190, 190, 0.5) !important;opacity: 0.85 !important;color:#82518c !important;}</style><link href=\"https://fonts.googleapis.com/css?family=Cookie\" rel=\"stylesheet\"><a class=\"bmc-button\" target=\"_blank\" href=\"https://www.buymeacoffee.com/brodriguesco\"><img src=\"https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg\" alt=\"Buy me an Espresso\"><span style=\"margin-left:5px\">Buy me an Espresso</span></a>\n\n\n",
    "created" : 1580046057274.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "661069663",
    "id" : "D1D78021",
    "lastKnownWriteTime" : 1580077339,
    "last_content_update" : 1580077339781,
    "path" : "~/Documents/b-rodrigues.github.com/content/blog/2020-01-26-harold.Rmd",
    "project_path" : "content/blog/2020-01-26-harold.Rmd",
    "properties" : {
        "marks" : "<:0,0\n>:23,-1\ne:0,0",
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}